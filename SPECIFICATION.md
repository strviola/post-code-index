# 技術資料

## キャッシュファイル

当プログラムでは以下の2種類のキャッシュファイルを使用します。

- post_code.rb (郵便番号インデックス)
- n_gram_dictionary_#{n}.rb (N-gram インデックス)

これらはディレクトリ lib/cache 以下に保存されます。

### 郵便番号インデックス

内容は定数 `POST_CODE_DICTIONARY` が定義された `module` となっています。これは Ruby スクリプトとして読み込むことができ、以下の通り郵便番号とレコードを対応付けています。 (可読性のため一部空白・改行・コメントを追加しています)

```post_code.rb
module PostCode
  POST_CODE_DICTIONARY = {
    "0600000" => [
      ["01101", "060  ", "0600000", "ホッカイドウ", "サッポロシチュウオウク", "イカニケイサイガナイバアイ",
      "北海道", "札幌市中央区", "以下に掲載がない場合", "0", "0", "0", "0", "0", "0"]
    ],
    "0640941" => [
      ["01101", "064  ", "0640941", "ホッカイドウ", "サッポロシチュウオウク", "アサヒガオカ",
      "北海道", "札幌市中央区", "旭ケ丘", "0", "0", "1", "0", "0", "0"]
    ],
    "0600041" => [
      ["01101", "060  ", "0600041", "ホッカイドウ", "サッポロシチュウオウク", "オオドオリヒガシ",
      "北海道", "札幌市中央区", "大通東", "0", "0", "1", "0", "0", "0"]
    ],
    # 中略
  }
end
```

なお、1つの郵便番号に対してレコードは複数存在する場合があるため、郵便番号に対応する値はレコードの配列となっています。この郵便番号が検索された場合、表示処理において以下の変換をしています。

- 町域名が **30文字** (※) 以上の場合
  - 分割されたデータと見なし、該当データを結合して表示
- それ以外
  - 重複データと見なす
  - 検索 keyword (N-gram 分割) を受け取り、住所レコードから改めて検索
  - keyword を全て含むレコードのみ表示

(※) [日本郵便による説明](http://www.post.japanpost.jp/zipcode/dl/readme.html) だと「38文字以上」の場合に分割されることになっていますが、実際はもっと短い文字列で分割されている場合があります。おそらく濁点・半濁点を1文字として計上しているためですが、 Ruby では同様の機能がないため閾値を若干小さくすることで対応しています。

### N-gram インデックス

内容は定数 `N_GRAM_DICTIONARY` が定義された `module` となっています。以下に 2-gram インデックスデータの例を示します。

```n_gram_dictionary_2.rb
module NGramDictionary2
  N_GRAM_DICTIONARY = {
    "北海" => ["0600000", "0640941", "0600041", "0600042", "0640820",], # 途中省略
    "海道" => ["0600000", "0640941", "0600041", "0600042", "0640820",], # 途中省略
    # 中略
  }
end
```

なお、このインデックスは住所文字列を結合した上で作成しているので、県と市区町村、市区町村と町域名にまたがったキーワードでも検索が可能です。 (例: "北海道伊達市" など)

## 検索方式

1. post_code.rb が存在しない場合、以下の処理を行う。存在する場合は次に進む。
  - [郵便番号CSVデータ](http://www.post.japanpost.jp/zipcode/dl/kogaki/zip/ken_all.zip) をダウンロード
  - Zip ファイルを展開
  - 文字コードが Shift-JIS なので UTF-8 に変換し KEN_ALL_UTF.csv として lib/cache に
  - KEN_ALL_UTF.csv を読み取り、郵便番号インデックスに変換して post_code.rb として保存
1. 実行引数から keyword, n を読み取る。
1. n_gram_dictionary_#{n}.rb が存在しない場合、以下の処理を行う。存在する場合は次に進む。
  - KEN_ALL_UTF.csv を読み取り、 N-gram インデックスに変換して n_gram_dictionary_#{n}.rb として保存
1. keyword を n 文字ずつに分割する。
1. `N_GRAM_DICTIONARY` から郵便番号の一覧を取得する。
1. `POST_CODE_DICTIONARY` から郵便番号に対応するレコードを取得し、結果を表示する。
  - データが分割されている場合は結合して表示される。

## 考察

### 時間計算量

今回、2種類のインデックスデータを Ruby スクリプトとしてキャッシュする方式を採用した理由として、時間計算量の削減があります。 Hash オブジェクトに対する参照処理は _O(1)_ 時間で実現できる ([参考](http://www.jaist.ac.jp/~kshirai/lec/i223/09.pdf)) ため、これを利用すれば以下の処理を _O(1)_ 時間にできます。

- 文字列 (N-gram 分割片) から郵便番号一覧の取得
- 郵便番号から対応するレコードの取得

実際は検索 keyword を N-gram 分割し、それぞれに対して郵便番号の取得を行います。このため郵便番号の検索には _O(size(keyword))_ を必要とします。ただし、影響は限定的で、この方式であれば keyword の長さは時間にあまり影響しません。

また、インデックスファイルの作成自体にも計算を必要としますが、以下の通り多項式時間となります。

- 郵便番号インデックス: _O(size(レコード))_
- N-gram インデックス: _O(size(レコード) * size(住所文字列))_

### 空間計算量

生成されたキャッシュファイル (post_code.rb および1〜4までの n_gram_dictionary_#{n}.rb) のファイルサイズを計測したところ、以下の通りでした。

```
$ ls -lh lib/cache/
total 242856
-rw-r--r--  1 suzukiryota  staff    14M  2 12 21:46 n_gram_dictionary_1.rb
-rw-r--r--  1 suzukiryota  staff    14M  2 12 21:55 n_gram_dictionary_2.rb
-rw-r--r--  1 suzukiryota  staff    15M  2 14 00:20 n_gram_dictionary_3.rb
-rw-r--r--  1 suzukiryota  staff    16M  2 12 22:01 n_gram_dictionary_4.rb
-rw-r--r--  1 suzukiryota  staff    22M  2 12 21:46 post_code.rb
```

各ファイル10〜20MB台であり、この点に関してはあまり効率的とは言えません。実際、これがネックとなり検索実行時にはインデックスファイルの読み込み (も含め処理全体) に7〜8秒要しています。

しかし、最初の読み込みに時間がかかる以外は非常に高速です。このボトルネックを解消するには、インデックスを読み込んだ結果を保存し、その上で検索処理を行うなどの仕様が考えられます。 (対話的コンソールを利用するなど)

## 課題・制限事項

- 上記の通りインデックスファイルが巨大なので、実行に時間を要します。
- フリガナでの検索には対応していません。対応させた場合、インデックスファイルがさらに巨大になることが予想されます。
- 町域表示が30文字以上、かつ重複した町域名の場合、本来結合されるべきでない町域表示が結合されて表示されることが考えられます。(現在のところ該当するデータは確認できていません)
